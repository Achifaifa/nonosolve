var canvas=document.getElementById("nonosolve");
canvas.style.background="#00"
var ctx=canvas.getContext("2d");
ctx.canvas.width=800
ctx.canvas.height=600
ctx.strokeStyle="white"
ctx.fillStyle="white"

//puzzles store first vertical, then horizontal
//All puzzles are autogenerated with https://monolifed.itch.io/nono
puzzles=[
  //seed 5629982287
  [
   [[1,8],[3,5],[2,1,4],[1,1,4],[3,2,1],[3,3,2],[2,1,3],[3,1,1,2],[2,1,3],[1,1,4,1]],
    [[10],[2,5],[2,2,1,1],[1,2,1,1],[2,2,1,1],[3,2,2],[4,5],[5,1,2],[4,3],[1,1,1,1,1]]
  ],
  //seed 6872171112
  [
  [[1,1,1,3],[1,1,3],[4,1,1],[6,1,1],[2,1],[2,2,2,1],[2,1,1,3],[2,1,4],[1,1,3,2],[6,3]],
  [[8],[1,6,1],[3,2],[1,2,3,1],[1,1,2],[2,1,4],[1,2,2],[2,1,3,1],[2,4],[4,2,2]]
  ],
  //seed 1159352292
  [
  [[4,5],[3,3,1],[4,2],[2,5,1],[2,2,3],[9],[4,1,3],[2,1,4],[1,2,1],[3,1,2,1]],
  [[2,5,1],[10],[3,2,1],[1,6],[5,2],[2,1,2,1],[2,1,1,1,1],[1,6,1],[3,5],[1,2,2,1]]
  ],
]
current_level=2

//0 -> empty place
//1 -> filled place
//2 -> discarded place
grid=[]

function reset_grid()
{
  grid=new Array(10).fill(0).map(()=>new Array(10).fill(0))
}

function draw_line(x1,y1,x2,y2)
{
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();
}

function draw_ui()
{
  ctx.textAlign="center"
  ctx.fillText("[space] STEP",400,550)
}

function draw_grid(id)
{
  for(i=0;i<11;i++){
    if(i<10){
      //horizontal
      ctx.textAlign="center"
      ctx.fillText(puzzles[id][0][i],220+40*i,80)
      //vertical
      ctx.textAlign="end"
      ctx.fillText(puzzles[id][1][i],180,120+40*i)
      
    }
    draw_line(200,100+40*i,600,100+40*i)
    draw_line(200+40*i,100,200+40*i,500)
  }
}

function fill_grid()
{
  for(i=0;i<10;i++){
    for(j=0;j<10;j++){
      sx=205+i*40
      sy=105+j*40
      if(grid[j][i]==1){
        ctx.fillRect(sx,sy,30,30)
      }
      else if(grid[j][i]==2){
        draw_line(sx,sy,sx+30,sy+30)
        draw_line(sx+30,sy,sx,sy+30)        
      }
    }
  }
}

function sum(arr)
{
  return arr.reduce((a,b)=>a+b,0)
}

function count(arr,it)
{
  return arr.filter(x => x==it).length
}

function solvestep()
{
  delta=0
  d=puzzles[current_level]
  v=d[0]
  h=d[1]

  //vertical full lines
  for(i=0;i<10;i++){
    
    if(sum(v[i])+v[i].length==11){
      
      //create line
      t=[]
      for(j=0;j<v[i].length;j++){
        t=t.concat(new Array(v[i][j]).fill(1))
        t=t.concat([2])
      }
      //apply line
      for(j=0;j<10;j++){
        if(grid[j][i]==0){delta=1}
        grid[j][i]=t[j]
      }
      //exit if changes were made (stepping)
      if(delta==1){
        console.log("Found full line (vertical "+(i+1)+")")
        return
      }
    }

    //horizontal full lines
    if(sum(h[i])+h[i].length==11){
      //create line
      t=[]
      for(j=0;j<h[i].length;j++){
        t=t.concat(new Array(h[i][j]).fill(1))
        t=t.concat([2])
      }
      for(j=0;j<10;j++){
        if(grid[i][j]==0){delta=1}
        grid[i][j]=t[j]
      }
      if(delta==1){
        console.log("Found full line (horizontal "+(i+1)+")")
        return
      }
    }
  
    //fill completed lines

    //columns
    if(sum(v[i])==count(grid.map(x=>x[i]),1)){
      for(j=0;j<10;j++){
        if(grid[j][i]==0){
          grid[j][i]=2
          delta=1
        }
      }
      if(delta==1){
        console.log("Added spaces to complete vertical line ("+(i+1)+")")
        return
      }
    }

    //rows
    if(sum(h[i])==count(grid[i],1)){
      for(j=0;j<10;j++){
        if(grid[i][j]==0){
          grid[i][j]=2
          delta=1
        }
      }
      if(delta==1){
        console.log("Added spaces to complete horizontal line ("+(i+1)+")")
        return
      }
    }

    //fill lines that have just enough spaces (e.g. 3 spaces and 3 missing squares)

    //columns
    if(sum(v[i])==count(grid.map(x=>x[i]),0)+count(grid.map(x=>x[i]),1)){
      for(j=0;j<10;j++){
        if(grid[j][i]==0){
          grid[j][i]=1
          delta=1
        }
      }
      if(delta==1){
        console.log("Filled incomplete vertical line ("+(i+1)+")")
        return
      }
    }

    //rows
    if(sum(h[i])==count(grid[i],0)+count(grid[i],1)){
      for(j=0;j<10;j++){
        if(grid[i][j]==0){
          grid[i][j]=1
          delta=1
        }
      }
      if(delta==1){
        console.log("Filled incomplete horizontal line ("+(i+1)+")")
        return
      }
    }

    //complete started blocks inside line (e.g. [3,5] in XXO--XXXOO)
    //probably makes initial/last blocks redundant

    //vertical
    //downward
    block=0
    ct=0
    for(j=0;j<10;j++){
      if(grid[j][i]==0 && ct<v[i][block] && ct>0){ //fill position if continuation of block
        grid[j][i]=1
        delta=1
      }
      if(grid[j][i]==1){ //Increase count if there's a block
        ct++
      }
      if(ct==v[i][block] && j+1<10){ //Add space in next position if block is finished
        grid[j+1][i]=2
      }
      if(v[i][block]==ct){ //go to next block if finished current one
        block++
        ct=0
      }
      if(grid[j][i]==0 && //if column can't be processed further, check if remaining blocks fit neatly
        sum(grid.map(x=>x[i]).slice(j))==0 && //If all remaining positions are free
        sum(v[i].slice(block))+v[i].slice(block).length==(11-j)){ // And the remaining blocks fit

          //generate array of remaining elements
          remaining=[]
          v[i].slice(block).forEach(x=>remaining=remaining.concat(new Array(x).fill(1)).concat([2]))
          remaining.pop()
          
          //replace empty slots with new elements
          for(k=0;k<remaining.length;k++){
            grid[j+k][i]=remaining[k]
          }
          delta=1
          break
      }
      else if(grid[j][i]==0){ //else, go to next column
        break
      }
    }
    if(delta==1){
      console.log("Continued block in column "+(i+1))
      return
    }

    //upward 

    //horizontal
    //left to right
    block=0
    ct=0
    for(j=0;j<10;j++){
      if(grid[i][j]==0 && ct<h[i][block] && ct>0){ //fill position if continuation of block
        grid[i][j]=1
        delta=1
      }
      if(grid[i][j]==1){ //Increase count if there's a block 
        ct++
      }
      if(ct==h[i][block] && j<9){ //Add space in next position if block is finished
        grid[i][j+1]=2
      }
      if(h[i][block]==ct){ //go to next block if finished current one
        block++
        ct=0
      }
      if(grid[i][j]==0 && //if column can't be processed further, check if remaining blocks fit neatly
        sum(grid[i].slice(j))==0 && //If all remaining positions are free
        sum(h[i].slice(block))+h[i].slice(block).length==(11-j)){ // And the remaining blocks fit

          //generate array of remaining elements
          remaining=[]
          h[i].slice(block).forEach(x=>remaining=remaining.concat(new Array(x).fill(1)).concat([2]))
          remaining.pop()
          
          //replace empty slots with new elements
          for(k=0;k<remaining.length;k++){
            grid[i][j+k]=remaining[k]
          }

          delta=1
          break
      }
      else if(grid[i][j]==0){ //else, go to next column
        break
      }
    }
    if(delta==1){
      console.log("Continued block in row "+(i+1))
      return
    }

    //reverse


  }
  
  console.log("nothing found")
  loop()
}

function loop()
{
  ctx.clearRect(0,0,800,600)
  draw_ui()
  draw_grid(current_level)
  fill_grid()
}

document.addEventListener('keydown', function(e) {
  // spacebar (32)
  if (e.keyCode==32) {
    solvestep()
    loop()
  }
});

reset_grid()
loop()